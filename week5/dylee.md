# 1. 복잡도

## 1. 시간 복잡도

### 1. source code를 실행시키면 일어나는 일

- 궁금한거 → 소스코드를 실행시키면 컴퓨터 구조에서 일어나는 일(z
1. 컴파일 단계
    - 소스코드를 기계어로 변환
    - 전처리(`#include`, `#define` 등의 지시문 처리) → 컴파일(소스코드를 어셈블리어로 변환) → 어셈블(어셈블리어를 기계어로 변환) → 링킹(여러 object file들과 라이브러리를 연결해 실행 파일 생성)
2. 프로그램 로딩
    - 실행 파일을 실행하면 → os 로더가 실행 파일을 메모리에 올리고 → 가상 메모리 할당(code, data, stack, heap) → PCB(프로세스 제어 블록)생성
        - 메모리 구성
        - stack + heap → 한 메모리 공간을 공유해서 사용, 프로그램 실행되는 동안 변하는 공간
            - stack: scope 저장(function call ~ function return 까지의 context로 매개변수, 리턴 주소)
            - heap: dynamic allocation → new, malloc, local variable(function안에서만 유효한 변수들)
        - static data segment → 상수, 정적 변수
        - text segment→ MIPS 기계어 코드
3. 런타임 초기화
    - 메모리에 로드된 후 실행 전 작업
    - 전역변수/정적변수 초기화, 동적 라이브러리 로딩, 런타임 시스템 초기화, C 런타임 라이브러리 초기화
4. main 함수 실행
    - stack frame 생성 → 명령어 포인터가 main 함수 시작점을 가리킴 → CPU가 **fetch-decode-execute** 사이클로 명령어들 실행 → 함수 호출 시 stack에 context 저장(매개변수, 리턴 주소)
5. 프로세스 종료
    - main이 return하거나 exit() 호출 시
    - 정리 작업(열린 파일 닫기, 메모리 해제) , OS에 종료 코드 전달, 메모리 회수(OS가 할당한 메모리 반환), PCB 삭제(프로세스 관련 정보 정리)

### 2. 빅오 표기법

- 입력 크기에 따라 어떠한 알고리즘이 실행되는데 걸리는 시간 → 주요 로직의 반복 횟수를 중점으로 측정됨
- 입력 범위 n을 기준으로 로직이 몇번 반복되는지 나타내는 표기법
- O(n)의 n이 1에 가까워질수록 효율적

## 2. 공간 복잡도

- 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양 → 정적 공간(static data segment) + 동적 공간(heap과 stack)
- 주요 자료형의 크기
    
    
    | **자료형** | **크기(Byte)** | **비트 수** | **값의 범위** |
    | --- | --- | --- | --- |
    | char | 1 | 8 | -128 ~ 127 (signed), 0~255 (unsigned) |
    | short | 2 | 16 | -32,768 ~ 32,767 (signed), 0~65,535 (unsigned) |
    | int | 4 | 32 | -2,147,483,648 ~ 2,147,483,647 (signed) |
    | unsigned int | 4 | 32 | 0 ~ 4,294,967,295 |
    | long | 4 | 32 | -2,147,483,648 ~ 2,147,483,647 (signed, 표준 C) |
    | long long | 8 | 64 | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (signed) |
    | float | 4 | 32 | 약 ±3.4 x 10^38 (7 자리 정밀도) |
    | double | 8 | 64 | 약 ±1.8 x 10^308 (15 자리 정밀도) |

## 3. 자료 구조에서의 시간 복잡도

| **자료구조** | **접근(Access, 인덱스)** | **탐색/검색** | **삽입** | **삭제** | **비고** |
| --- | --- | --- | --- | --- | --- |
| 배열 | O(1) | O(n) | O(n) | O(n) | 인덱스로 바로 접근 가능 |
| 스택/큐 | O(n) | O(n) | O(1) | O(1) | top/front만 O(1), 나머진 O(n) |
| 힙 (Heap) | O(n) | O(n) | O(log n) | O(log n) | 최대/최소값 접근만 O(1) |
| 연결리스트 | O(n) | O(n) | O(1) | O(1) | 순차 탐색 필요 |
| 해시 테이블 | O(n) | O(n) | O(n) | O(n) | 인덱스 접근이 아닌 Key 기준 |
| 이진탐색트리(BST) | O(n) | O(n) | O(n) | O(n) | 정렬된 순서 접근은 O(n) |
| AVL 트리 | O(log n) | O(log n) | O(log n) | O(log n) | 인덱스 접근은 순회 필요 |
| 레드-블랙 트리 | O(log n) | O(log n) | O(log n) | O(log n) | 인덱스 접근은 순회 필요 |

# 2. 선형 자료 구조

- 요소가 일렬로 나열되어 있는 자료구조

## 1. 연결 리스트

- 데이터를 감싼 노드를 prev, next 포인터로 앞, 뒤 노드를 연결해서 공간 효율성을 극대화시킨 자료 구조
- 삽입, 삭제 → O(1), 탐색 → O(n) ⇒ 데이터 추가와 삭제가 많으면 연결 리스트가 유리
- 싱글 연결 리스트: next 포인터만 가짐
- 이중 연결 리스트: next, prev 포인터들 가짐
- 원형 이중 연결 리스트: next, prev 포인터를 가지고 마지막 노드의 next 포인터가 헤드 노드를 가리킴

### 이중 연결 리스트 구현(java)

## 2. 배열

- 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며 인접한 메모리 위치에 있는 데이터를 모아놓은 집합으로 중복을 허용하고 순서가 있음
- 접근(참조) → O(1), 삽입,삭제 → O(n) ⇒ 접근과 참조를 많이 하는 데이터는 배열이 유리

### 랜덤 접근과 순차적 접근

- 랜덤 접근: 동일한 시간에 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 순차 접근: 데이터를 저장된 순서대로 검색해야 함
- 배열은 랜덤 접근이 가능하지만 O(1)
- 연결 리스트는 랜덤 접근이 불가능하다 O(n)

## 3. 벡터

- 동적으로 요소를 할당할 수 있는 동적 배열 → 컴파일 시점에 개수를 모른다면 벡터를 쓰자
- 중복 허용, 랜덤 접근 가능
- 탐색, 맨 뒤의 요소 삭제 및 삽입 → O(1)
- 맨 뒤가 아닌 요소를 삭제하고 삽입 → O(n)

## 4. 스택

- LIFO
- 재귀 함수, 알고리즘, 웹 브라우저 방문 기록 등에 사용
- 삽입 및 삭제 → O(1), 탐색 → O(n)

## 5. 큐

- FIFO
- 삽입 및 삭제 → O(1), 탐색 → O(n)
