# Chapter5 자료구조

1. [복잡도](#51-복잡도)
2. [선형 자료 구조](#52-선형-자료-구조)
3. [비선형 자료 구조](#53-비선형-자료-구조) -> 다음주차!

# 5. 자료구조

**자료구조** : 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

**C++** : STL을 기반으로 전반적인 자료 구조를 가장 잘 설명할 수 있는 언어

> **STL이란?** <br>
> C++의 표준 템플릿 라이브러리이자 스택, 배열 등 데이터 구조의 함수 등을 제공하는 라이브러리의 묶음

## 5.1 복잡도

**시간복잡도 & 공간복잡도**로 나뉜다!

### 5.1.1 시간 복잡도

**빅오 표기법**

**시간복잡도** : 입력크기에 대해 어떠한 알고리즘이 실행되는데 걸리는 시간, 주요 로직의 반복 횟수를 중점으로 측정됨.

⇒ 보통 **빅오 표기법**으로 나타냄
=> 입력 범위 n을 기준으로 해서 로직이 몇번 반복되는지 나타냄

#### 코드 예시

```java
// 이진탐색
public static int binarySearch(int[] arr, int target){
  int left = 0;
  int right = arr.length - 1;

  while (left <= right){
    int mid = (left+right) / 2;
    if (arr[mid] == target) {
      return mid;
    }
    else if (arr[mid] < target){
      left = mid + 1;
    }
    else {
      right = mid - 1;
    }
  }
  return -1;
}
```

=> 이런 이진탐색의 경우에는 O(logN) 로그 시간임

**시간 복잡도의 존재 이유**

효율적인 코드로 개선하는 데 쓰이는 척도

**시간 복잡도의 속도 비교**

![image.png](https://velog.velcdn.com/images/hyoon1129/post/ba24a98e-8b89-40b5-b25d-bfa177774af9/image.png)

### 5.1.2 공간 복잡도

프로그램을 실행시켰을 떄 필요로 하는 자원 공간의 양

```java
int a[1004];
```

=> 1004 × 4바이트 = 4016바이트 ≈ 4KB 정도

### 5.1.3 자료 구조에서의 시간 복잡도

#### 평균 시간 복잡도

| 자료구조                                  | 접근 (Access) | 탐색 (Search) | 삽입 (Insert) | 삭제 (Delete) |
| :---------------------------------------- | :-----------: | :-----------: | :-----------: | :-----------: |
| **배열 (Array)**                          |     O(1)      |     O(n)      |     O(n)      |     O(n)      |
| **스택 (Stack)**                          |     O(n)      |     O(n)      |     O(1)      |     O(1)      |
| **큐 (Queue)**                            |     O(n)      |     O(n)      |     O(1)      |     O(1)      |
| **이중 연결 리스트 (Doubly Linked List)** |     O(n)      |     O(n)      |     O(1)      |     O(1)      |
| **해시 테이블 (Hash Table)**              |     O(1)      |     O(1)      |     O(1)      |     O(1)      |
| **이진 탐색 트리 (BST)**                  |   O(log n)    |   O(log n)    |   O(log n)    |   O(log n)    |
| **AVL 트리**                              |   O(log n)    |   O(log n)    |   O(log n)    |   O(log n)    |
| **레드블랙 트리**                         |   O(log n)    |   O(log n)    |   O(log n)    |   O(log n)    |

#### 최악의 시간 복잡도

| 자료구조                                  | 접근 (Access) | 탐색 (Search) | 삽입 (Insert) | 삭제 (Delete) |
| :---------------------------------------- | :-----------: | :-----------: | :-----------: | :-----------: |
| **배열 (Array)**                          |     O(1)      |     O(n)      |     O(n)      |     O(n)      |
| **스택 (Stack)**                          |     O(n)      |     O(n)      |     O(1)      |     O(1)      |
| **큐 (Queue)**                            |     O(n)      |     O(n)      |     O(1)      |     O(1)      |
| **이중 연결 리스트 (Doubly Linked List)** |     O(n)      |     O(n)      |     O(1)      |     O(1)      |
| **해시 테이블 (Hash Table)**              |     O(n)      |     O(n)      |     O(n)      |     O(n)      |
| **이진 탐색 트리 (BST)**                  |     O(n)      |     O(n)      |     O(n)      |     O(n)      |
| **AVL 트리**                              |   O(log n)    |   O(log n)    |   O(log n)    |   O(log n)    |
| **레드블랙 트리**                         |   O(log n)    |   O(log n)    |   O(log n)    |   O(log n)    |

## 5.2 선형 자료 구조

요소가 **일렬**로 나열되어 있는 자료 구조

### 5.2.1 연결 리스트

데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조

삽입 : O(1)

삭제 : O(1)

탐색 : O(n)

**종류**

**싱글 연결 리스트** - next 포인터만 가짐

**이중 연결 리스트** - next 포인터와 prev 포인터를 가짐

**원형 이중 연결 리스트** - 이중연결리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리킴

### 5.2.2 배열

== 정적 배열 기반 설명==

1. **같은 타입의 변수**들로 이루어짐.
2. **크기가 정해져 있음**
3. 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
4. **중복 허용**
5. 순서 있음

접근 : O(1), 랜덤접근 가능

삽입 : O(n)

삭제 : O(n)

=> 따라서 삽입 삭제 O(n) 이니까, 삽입 삭제 많이하면 연결리스트를 하는 게 좋음

**랜덤 접근과 순차적 접근**

**랜덤 접근(= 직접 접근)**

동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능

ex) 배열 (Array)

> 순차적 접근 (데이터를 처음부터 차례대로 읽어나가야하는 방식) <br>
> 연결 리스트, 큐, 스택...

**배열과 연결 리스트 비교**

**배열** - 상자를 순서대로 나열한 구조

**연결리스트** - 상자를 선으로 연결한 형태의 데이터 구조

- 참조가 많은 작업의 경우 => 배열이 빠르다!
- 데이터 삽입 및 삭제가 많은 작업의 경우 => 연결리스트가 더 빠르다!

## 5.2.3 벡터

동적으로 요소를 할당할 수 있는 **동적 배열**

컴파일 시점에 개수를 모르면 벡터를 쓰자!

**중복을 허용**, **순서가 있음**

**랜덤접근 가능**

탐색 : O(1)

맨뒤의 요소 삭제 : O(1)

맨뒤의 요소 삽입 : O(1)

맨뒤가 아닌 요소 삭제 : O(n)

맨뒤가 아닌 요소 삽입 : O(n)

### 5.2.4 스택

**LIFO** : Last In First Out

재귀적인 함수, 알고리즘에 사용됨. 웹 브라우저 방문 기록 등에 쓰임

탐색 : O(n)

삽입 : O(1)

삭제 : O(1)

## 5.2.5 큐

**FIFO** : First In First Out

탐색 : O(n)

삽입 : O(1)

삭제 : O(1)

```java
Queue<Integer> q = new ArrayDeque<>();
q.offer(1);
int x = q.poll(); 
```

