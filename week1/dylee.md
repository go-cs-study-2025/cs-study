## 1. 데이터베이스의 기본

- 데이터베이스
    - 일정한 규칙, 규약을 통해 구조화되어 저장된 데이터의 모음
- DBMS
    - 데이터베이스 제어, 관리하는 통합 시스템
    - 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회등을 수행할 수 있음
        - DML(Data Manipulation Language) → 데이터 조작어
            - select, insert, update, delete → 데이터 조회, 삽입, 수정, 삭제
        - DDL(Data Definition Language) → 데이터 정의어
            - create, alter, drop, rename, truncate → table과 같은 데이터 구조를 정의하는 데 사용되는 명령어로 생성, 변경, 삭제, 이름변경 등등
        - DCL(Data Control Languate) → 데이터 제어어
            - grant, revoke → 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령어
        - TCL(Transaction Control Language) → 트랜잭션 제어어
            - commit, rollback, savepoint → 논리적인 작업의 단위를 묶어 DML에 의해 조작된 결과를 트랜잭션(작업단위)별로 제어하는 명령어
    - 데이터베이스는 실시간 접속, 공유 가능
    - 응용 프로그램 ↔ DBMS ↔ DB 구조 기반으로 데이터를 주고 받는다

### 1. Entity

- 여러 개의 속성을 지닌 명사 → 서비스의 요구 사항에 맞춰 속성이 정해짐
    - ex) 회원 entity는 이름, 아이디, 주소, 전화번호 속성을 가지고 있음
- 약한 entity, 강한 entity
    - 강한 entity: 스스로 존재할 수 있으며 자신만의 고유한 pk를 가짐
    - 약한 entity: 스스로 존재할 수 없으며 강한 엔티티에 종속적으로 존재
    
    → 약한 entity의 pk는 강한 entity의 pk를 포함하는 복합 키(약한 entity의 fk + 약한 entity의 부분 key)
    
    - 강한 엔티티 ↔ 강한 엔티티: 강한 관계
    - 강한 엔티티 ↔ 약한 엔티티: 약한 관계

### 2. relation
- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위로 entity에 관한 데이터를 relation 하나에 담아 관리
- relation = table(RDBMS) = collection(NoSQL)
- table과 collection
    - RDBMS: record - table - database
        - record가 쌓여서 table이 되고 → table이 쌓여서 database가 됨
    - NoSQL: document - collection - database
        - document가 쌓여서 collection이 되고 → collection이 쌓여서 database가 됨

### 3. 속성

- relation에서 관리하는 구체적이고 고유한 이름을 갖는 정보
- 회원 엔티티의 속성 → 이름, 아이디, 주소, 전화번호, 성별

### 4. 도메인

- relation에 포함된 각각의 속성들이 가질 수 있는 값의 집합
- 회원 엔티티의 속성 중 성별에 대한 도메인 → 남,여

### 5. 필드와 레코드

- 테이블은 필드와 레코드로 구성됨
- 회원 entity
    - table → member
    - 속성,field,column → name, id, address, phonenumber
    - record = tuple→ row 단위의 데이터
- field에는 숫자 타입, 날짜 타입, 문자 타입 등등이 존재함

### 6. 관계

- 1:1 관계
    - 하나의 A가 하나의 B로 구성되어 있음
    - ex) 유저table과 유저의 이메일 table
- 1:N 관계
    - 하나의 A는 하나 이상의 B로 구성되어 있음
    - ex) 유저 tabler과 상품 table
- N:M 관계
    - A도 여러 개의 B로 구성되어 있고 B도 여러 개의 A로 구성되어 있음
    - ex) 학생 table과 강의 table

## 7. 키

- table간의 관계를 조금 더 명확하게 하고 table 자체의 index를 위해 설정된 장치
- 기본키(PK)
    - 유일성과 최소성을 만족하는 key
    - 자연키
        - 중복되지 않는 것을 자연스럽게 뽑다가 나오는 key
        - 자연키는 언젠가는 변함
    - 인조키
        - 인위적으로 생성한 키 → 안변함
        - 일반적으로 PK로 설정
- 외래키(FK)
    - 다른 테이블의 기본키를 그대로 참조하는 값
    - 개체와의 관계를 식별하는 데 사용
    - 중복되어도 괜찮음
- 후보키
    - 기본키가 될 수 있는 후보들로 유일성과 최소성을 동시에 만족
- 대체키
    - 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들
- 슈퍼키
    - 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## 2. ERD와 정규화 과정

- ERD
    - 데이터베이스에서 릴레이션 간의 관계들을 정의한 것
    - DB의 설계도
    - 비정형 데이터를 충분히 표현할 수 없음
        - 비정형 데이터: 비구조화 데이터, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정의되지 않은 정보

### 정규화

- 릴레이션 간의 잘못된 종속 관계로 인한 데이터베이스 이상 현상을 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
    - 데이터베이스 이상 현상: 테이블을 잘못 설계하여 데이터를 삽입, 설계, 수정할 때 논리적으로 생기는 오류
- 정규형 원칙
    - 자료의 중복성은 감소하고, 독립적인 관계는 별개의 릴레이션으로 표현하고, 각각의 릴레이션은 독립적인 표현이 가능해야 함
- 제 1 정규형
    - 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값만으로 구성됨
    - 릴레이션의 속성값 중 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안됨
- 제 2 정규형
    - 릴레이션이 제 1 정규형이며 부분 함수의 종속성을 제거한 형태
    - 모든 속성이 기본키에 완전 함수 종속적
    - 정보 손실이 발생하지 않아야 함
- 제 3 정규형
    - 제 2 정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태
        - 이행적 함수 종속: A → B와 B → C가 존재하면 논리적으로 A → C가 성립 ⇒ 이때 C가 A에 이행적 함수 종속
- 보이스/코드 정규형 (제 3 정규형의 강화 버전)
    - 제 3 정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태
        - 결정자: 함수 종속 관계에서 특정 종속자를 결정짓는 요소. A → B 일때 A는 결정자, B는 종속자
    - 예시
        - {학번, 수강명} , {학번,강사}는 각각 유일성과 최소성을 동시에 만족시키는 후보키
        - 기본키가 될 수 있는 후보들로 유일성과 최소성을 동시에 만족
        - 함수 종속: 학번 → 강사 , 강사 → 수강명
- 서비스에 따라 정규화 또는 비정규화 과정을 진행하기(테이블을 너무 많이 나오면 과도한 join으로 성능이 나빠 질 수도..)

## 3. 트랜잭션과 무결성

### 1. 트랜잭션

- 트랜잭션: 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 → ACID(원자성, 일관성, 독립성, 지속성)
    - 원자성 = all or nothing
        - 트랜잭션과 관련된 일이 모두 수행되었거나, 되지 않음을 보장
        - 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안됨 → 트랜잭션 전파를 신경 써서 관리할 것
        - 커밋과 롤백
            - 커밋: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어로 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장됨(커밋 수행 = 하나의 트랜잭션 수행)
            - 롤백: 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌림
            - 커밋, 롤백으로 데이터 무결성 보장 + 작업 그룹화
        - 트랜잭션 전파
            - 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것(트랜잭션 수행 시 커넥션 단위로 수행 → 커넥션 객체를 넘겨서 수행해야 함 → 번거롭다..)
            - Spring의 @Transactional → 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리
    - 일관성(Consistency)
        - 허용된 방식으로만 데이터를 변경해야 함
    - 격리성(Isolation)
        - 트랜잭션 수행 시 서로 끼어들지 못하는 것
        - 병렬 트랜잭션 → 서로 격리되어 순차적으로 실행되는 것 처럼 보여야 함
        - 데이터베이스 → 여러 사용자가 같은 데이터에 접근할 수 있어야 함
        - 격리 수준
            - 격리 수준에 따라 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 발생
                - 팬텀 리드: 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우()
                - 반복 가능하지 않은 조회: 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데 그 값이 다른 경우
                - 더티 리드: 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽을 수 있을 때 발생
            - Serializeable(제일 엄격)
                - 트랜잭션을 순차적으로 진행 → 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음 → 교착상태 제일 많고 가장 성능이 떨어짐
            - Repeatable_Read
                - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않음 → 팬텀 리드 발생할수도..
                - MySQL InnoDB의 기본값
            - Read_Commited
                - 가장 많이 사용되는 격리 수준, PostgreSQL, SQL Server, Oracle의 기본값
                - 커밋 완료된 데이터에 대해서만 조회 허용
                - 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수행 가능 → 팬텀 리드, 반복 가능하지 않은 조회 발생
            - Read_Uncommited
                - 가장 낮은 격리 수준으로 가장 빠름
                - 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있음 → 격리성이 약하고 동시성이 강함, 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 발생
                - 데이터 무결성을 위해 사용을 지양 → 하지만 빅데이터 대충 집계하는데 사용하는건 굿
    - 지속성(Durability)
        - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함 → db에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함 → 체크섬, 저널링, 롤백 등..

### 2. 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성의 종류
    - 개체 무결성: 기본키로 선택된 필드는 빈 값을 허용하지 않음
    - 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
    - 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐
    - NULL 무결성: 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약조건

## 4. 데이터베이스의 종류

### 1. 관계형 데이터베이스

- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- SQL로 조작
- MySQL
    - MyISAM 인덱스 압축 기술, B-Tree 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 빠른 join, 최대 64개의 index 제공
    - 현재는 MyISAM storage대신 InnoDB를 MySQL의 storage engine으로 사용함
    - 구조
        - MySQL 접속 클라이언트: 사용자가 이 계층을 통해 MySQL에 접속하고 쿼리 실행
            → MySQL Connector(jdbc,python,php,node.js)
        - MySQL엔진: 클라이언트로부터 전달받은 SQL 쿼리 해석, 실행
            - NoSQL Interface: sql없이 데이터를 다루는 방식
            - SQL Interface: DML, DDL, DCL등 쿼리를 받아서 다음 단계인 Parser로 넘겨 주는 역할로 view, trigger, procedure같은 고급 SQL 기능 처리
            - Parser: SQL 문장 정리, 검사하는 전처리 단계
            - Optimizer: 테이블 읽는 순서, 인덱스 사용 유무, join 방식 등 가장 효율적인 쿼리 실행 방법(실행계획)을 찾음 → 성능에 매우 큰 영향을 줌
            - Caches & Buffers: 메모리 최적화를 하여 속도 향상 → sort, join, 임시 table 생성 등 중간 작업의 임시 저장소 + 캐싱
        - MySQL 스토리지 엔진: 실제 데이터를 저장하고, 불러오고, 수정하는 역할로 데이터를 디스크에 저장함 (사용자가 query 보냄 → SQL engine → storage engine → data를 디스크에 저장 또는 조회)
            - MySQL에서 storage engine의 종류 → MySQL은 하나의 DBMS안에서 다양한 스토리지 엔진을 사용할 수 있음
                - InnoDB: MySQL default storage engine, 트랜잭션 왜래키 롤백 등 지원. 제일 많이 사용함
                    - InnoDB의 특징
                        - 클러스터링 인덱스 구조 지원 → 테이벌의 데이터를 PK순서대로 정렬하여 디스크에 저장, pk index 자동 생성, pk를 통해 record에 접근 가능, pk를 통한 검색 매우 빠름, 클러스터링 사용 → 읽기엔 최적화 되어 있지만 쓰기엔 최적화 x
                            
                            → pk 수정 및 중간에 삽입하는 것과 랜덤한 값(uuid)를 pk로 사용하는 경우를 지양하자..! 안그러면 병목이 발생할 수도..
                            
                            - 병목 발생 이유? 클러스터링 인덱스 구조에서 InnoDB는 자동으로 pk를 B-tree에 저장 → 랜덤한 값이 삽입 → B-tree에 저장된 pk 값 재정렬 발생 → disk I/O 폭증(병목 현상)
                        - MVCC 지원
                            - 동시에 여러 트랜잭션이 데이터를 접근할 수 있도록 허용하면서 데이터의 일관성을 유지하기 위한 기술
                            - Lock없이 읽기 작업 가능
                        - Undo Log & Redo Log
                            - ACID를 보장하기 위해 사용
                            - Undo Log: 변경되기 이전 데이터 → rollback시 undo log를 통해 데이터 복원 → 트랜잭션 격리 수준 보장
                            - Redo Log: 변경된 데이터 백업(commit 완료된 데이터) → 영속성 보장(서버 비정상 종료 시 redo log에 백업된 데이터 복원)
                        - 레코드 단위 잠금
                            - 데이터 읽거나 수정할 때 해당 레코드만 잠금 (table전체 Lock x)
                            - index를 어떻게 설정하는지에 따라 record의 잠금 범위가 달라질 수 있음
                - MyISAM: 이전의 default engine으로 읽기 성능은 빠르지만 트랜잭션 지원 x
        - 운영체제, 하드웨어: 스토리지 엔진이 데이터를 처리하면 file system을 통해 디스크에 저장
            - 파일 시스템
                - InnoDB: .ibd, ibdata1, Redo/Undo 로그 파일 등으로 데이터를 저장
                - MyISAM:  .MYD, .MYI, .frm 등의 파일로 관리
            - 디스크 I/O
                - 실제 디스크에 쓰는 작업 → 운영체제가 처리
                - MySQL은 내부적으로 캐싱(Buffer Pool)을 사용해 디스크 접근을 최소화하고 성능을 높임
            - OS 자원 관리
                - CPU, 메모리, 파일 디스크럽터 수, 스레드 수 등도 os에 의존 → 서버 튜닝 시 os 계층까지 고려해야 함
- PostgreSQL
    - VACCUM(디스크 조각이 차지하는 영역을 회수하는 장치)
    - 최대 테이블 크기 32TB
    - SQL, JSON을 이용해 데이터에 접근 가능
    - 복구 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 가능

### 2. NoSQL

- MongoDB
    - JSON을 통해 데이터에 접근할 수 있음
    - Binary JSON 형태로 데이터가 저장됨
    - 기본 스토리지 엔진 → 와이어드 타이거
    - key-value data model에서 확장된 document기반의 database → document 생성할 때 마다 ObjectID 생성됨
    - 고가용성, 샤딩, replicaset지원
    - 스키마 x → 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 좋음
- Redis
    - 인메모리 데이터베이스, Key-value 데이터 모델 기반의 데이터베이스
    - 기본적인 데이터 타입 → string
    - set, hast등 지원
    - pub/sub 기능을 통해 채팅 시스템, 캐싱, 세션 정보 관리(key-value), sorted set 자료 구조 등등
