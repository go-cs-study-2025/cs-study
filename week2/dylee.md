## 5. 인덱스

### 1. 인덱스의 필요성

- 인덱스를 설정하면 table 안의 데이터를 빠르게 찾을 수 있음

### 2. B-Tree

- 인덱스의 자료 구조로 루프노드, 리프 노드, 브랜치 노드로 이루어짐
- 탐색 과정
    - 루트 노드부터 탐색해서 → 브랜치 노드를 거쳐 → 리프 노드에 도달해 찾고자 하는 값이 가리키는 포인터를 통해 결과 반환
- 인덱스가 효율적인 이유
    - B-Tree는 하나의 노드에 많은 key를 저장해서 트리를 넓고 얕게 만듬 → 이때 트리의 깊이 = 데이터 탐색에 필요한 디스크 접근 횟수 이므로, 깊이가 얕은 B-Tree는 디스크에 적게 접근 → 디스크 I/O를 줄이면서 인덱스를 통한 빠른 검색 가능

### 3. 인덱스 만드는 방법

- MySQL
    - 클러스터형 인덱스: primary key, unique not null 옵션 → 하나의 field만으로 query 보낼 때 유리
    - 세컨더리 인덱스(보조 인덱스) : create index 명령어 사용 → 여러 개의 field 기반으로 query 보낼 때 유리
- MongoDB
    - document 만들면 자동으로 objectId 생성 → 이게 pk로 설정됨
    - 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스도 설정 가능

### 4. 인덱스 최적화 기법

- 필요한 field만 인덱스를 설정하자
    - 인덱스는 인덱스 리스트 → 컬렉션 순으로 2번 탐색되고(읽기 비용 증가)
    - 컬렉션이 수정되면 인덱스도 수정되어야 함→ B-Tree 수정하는 비용 고려해야 함(쓰기 비용 증가)
- 테스트 후 인덱스를 적용하자
    - explain()함수로 테스트 후 적절한 것을 적용하자
- 순서를 고려해서 복합 인덱스를 생성하자
    - 인덱스 생성 우선 순위
        1. == 또는 equal
        2. 정렬에 쓰는 field
        3. 단일 값을 출력해야 하는 필드(다중 값을 출력해야 하는 필드는 나중에 인덱스 설정)
        4. 카디널리티가 높은 필드 → 더 유니크한 필드 먼저 인덱스를 설정하자

## 6. 조인의 종류

- join: 두 개 이상의 테이블을 묶어 하나의 결과물을 만드는 것
- inner join: 교집합
- left outer join: 왼쪽 테이블의 모든 행이 결과 테이블에 표기됨 → 오른쪽 테이블에 일치하는 항목이 없다면 null로 표기됨
- right outer join: 오른쪽 테이블의 모든 행이 결과 테이블에 표기됨 → 왼쪽 테이블에 일치하는 항목이 없다면 null로 표기됨
- full outer join: 합집합

## 7. 조인의 원리

### 1. 중첩 루프 조인(Nested Loop Join)

- 중첩 for loop와 같은 원리로 조건에 맞는 join → 랜덤 접근에 대한 비용이 많이 증가해 대용량 테이블에서는 사용 x
- t1, t2 테이블을 join 한다면 → 첫 번째 테이블에서 행을 한 번에 하나씩 읽고 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결과 반환

### 2. 정렬 병합 조인

- 각각 테이블을 join할 필드 기준으로 정렬하고, 정렬이 끝난 후 join 작업을 수행하는 것
- join 할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 join 하고, join 조근으로 범위 비교 연산자가 있을 때 사용

### 3. 해시 조인

- 해시 테이블 기반으로 한 join
- 2개의 테이블 join 시 하나의 테이블이 메모리에 온전히 들어간다면 NLJ보다 효율적
- equal join 에서만 사용 가능
- 사용 가능한 메모리양 → join_buffer_size에 의해 제어되며 런타임 시 조정 가능
- 단계
    1. 빌드 단계
        - 입력 테이블 중 하나(byte가 더 작은 테이블)를 기반으로 메모리 내 해시 테이블을 빌드
        - join에 사용되는 field가 해시 테이블의 키로 사용됨
    2. 프로브 단계
        - 레코드 읽기 시작 → 조건에 일치하는 레코드를 찾아 반환
