# 4.5 인덱스

## 4.5.1 인덱스의 필요성

**`인덱스`** : 데이터를 빠르게 찾을 수 있는 하나의 장치

## 4.5.2 B-트리

인덱스는 보통 `B-트리` 라는 자료구조로 이루어져 있음

**`B-트리`**

루트 노드, 리프 노드, 그리고 루트노드, 리프노드 사이의 브랜치 노드로 나뉨

1. 맨위 루트 노드부터 탐색

2. 브랜치노드를 거쳐 리프노드까지 내려옴






<br>

**인덱스가 효율적인 이유와 대수 확장성**

`균형잡힌 트리 구조`와 트리 깊이의 `대수확장성` 때문임

#### 대수확장성이란?

트리 깊이가 리프노드 수에 비해 매우 느리게 성장하는 것을 의미함

기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

## 4.5.3 인덱스 만드는 방법

인덱스를 만드는 방법은 DB마다 다름

MySQL, MongoDB를 기준으로 설명

### MySQL

클러스터형 인덱스와 세컨더리 인덱스 존재

**클러스터형 인덱스**

데이터베이스에서 실제 데이터의 물리적인 저장 순서가 인덱스 순서와 동일하게 정렬되어 있는 인덱스

테이블당 하나 설정 가능

primary key 옵션으로 기본키로 만들면 ⇒ 클러스터형 인덱스 생성가능

기본키로 만들지 않고, unique not null 옵션 붙이면 ⇒ 클러스터형 인덱스로 만들 수 있음

**세컨더리 인덱스**

데이터베이스에서 실제 데이터의 물리적인 저장 순서와는 독립적으로 별도의 구조로 유지되는 보조 인덱스

create index .. 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있음

보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼때 생성해야 하는 인덱스

### MongoDB

MongoDB는 클러스터형 인덱스(Clustered Index) 라는 개념을 명시적으로 사용하지 않음

기본적으로 모든 컬렉션이 \_id 필드 기준으로 정렬된 인덱스 구조를 가지고 있음.

도큐먼트를 만들면 자동으로 ObjectID가 형성

해당 키가 기본키로 설정

세컨더리 키도 부가적으로 설정해서 기본키와 세컨더리 키를 같이 쓰는 복합 인덱스 설정 가능

## 4.5.4 인덱스 최적화 기법

> MongoDB 기반으로 인덱스 최적화 기법 설명

### 1. 인덱스는 비용이다

1.  인덱스는 두번 탐색 하도록 강요
2.  인덱스 리스트 → 컬렉션 순으로 탐색
3.  컬렉션이 수정되었을 때 인덱스도 수정되어야함

### 2. 항상 테스팅하라

1.  인덱스 최적화 기법은 서비스 특징에 따라 달라짐
2.  쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화 해야함

> MySQL 에서는 다음과 같은 코드로 테스팅을 수행한다.

```sql
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

### 3. 복합 인덱스는 같음, 정렬, 다중값, 카디널리티 순

1.  생성 순서에 따라 인덱스 성능이 달라짐
2.  따라서 같음→정렬→ 다중값→ 카디널리티 순으로 생성해야함

# 4.6 조인의 종류

> 조인이란? 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말함

> MySQL에서는 JOIN 이라는 쿼리로, MongoDB에서는 lookup이라는 쿼리로 이를 처리할 수 있음, **단** MongoDB를 사용할 때 lookup은 되도록 사용하지 말아야 함. MongoDB는 조인 연산에 대해 관계형 데이터베이스보다 성능이 떨어진다!

**내부조인** : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기

**왼쪽조인** : 왼쪽 테이블의 모든 행이 결과 테이블에 표기

**오른쪽조인** : 오른쪽 테이블의 모든 행이 결과 테이블에 표기

**합집합 조인** : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

## 4.6.1 내부 조인

두 테이블 간의 **교집합을** 나타냄

```java
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

## 4.6.2 왼쪽 조인

테이블 b의 일치하는 부분의 레코드와 함께 테이블 a를 기준으로 완전한 레코드 집합을 생성

만약 테이블 B에 일치하는 항목이 없으면 해당 값은 NULL 값이 됨

```java
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

## 4.6.3 오른쪽 조인

오른쪽 조인은 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성

만약 테이블 A에 일치하는 항목이 없으면 해당 값은 NULL 값이 됨

```java
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

## 4.6.4 합집합 조인

양쪽 테이블에서 일치하는 레코드와 함께 테이블 a와 테이블 b의 모든 레코드 집합을 생성

일치하는 항목이 없으면 누락된 쪽에 NULL 값이 포함되어 출력됨.

```java
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key
```

# 4.7 조인의 원리

## 4.7.1 중첩 루프 조인

중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법인데

랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않음

## 4.7.2 정렬 병합 조인

각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인

## 4.7.3 해시 조인

해시 테이블을 기반으로 조인하는 방법

두 개의 테이블을 조인하다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면, 보통 중첩 루프 조인보다 더 효율적임

mysql에서 해시조인단계는 **빌드단계**, **프로브단계**로 나뉨

### 빌드 단계

입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계

### 프로브 단계

레코드 읽기를 시작하며, 각 레코드에서 persons.country_id 에 일치하는 레코드를 찾아서 결괏값으로 반환

⇒ 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋음

# 부록

## Q1. 데이터베이스는 무엇인가요?

1.데이터베이스는 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

2.해당 데이터베이스를 제어 관리하는 통합 시스템을 DBMS라고 하며 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입 삭제 수정 조회 등을 수행할 수 있음

3.실시간 접근과 동시공유가 가능

## Q2. 중첩루프조인이 무엇인가요?

중첩 FOR 문과 같은 원리로 조건에 맞는 조인을 하는 방법

랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않음

## Q3. 인덱스를 매 필드마다 설정하는 것이 좋을까요?

인덱스는 두 번 탐색을 강요함

테이블이 수정되면 인덱스도 수정되어야함

→ 필드에 인덱스를 무작정 다 설정하는 것이 답은 아님

→ 컬렉션에서 가져와야하는 양이 많을수록 인덱스를 사용하는 것은 비효율적임
