# 4.5. 인덱스

## 4.5.1. 인덱스의 필요성

---

### 인덱스(Index)란?

: 데이터를 빠르게 찾을 수 있도록 하는 장치.

## 4.5.2. B-트리

---

### 인덱스(Index)의 구조

: B-트리라는 자료구조로 이루어짐.

→ 루트 노드-브랜치노드-리프 노드로 구성.

### 트리 탐색

: 루트 노드 탐색 → 브랜치 노드 탐색 → 리프 노드 탐색 → 찾고자 하는 데이터가 가리키는 데이터 포인터를 통해 결과값 반환.

### 인덱스가 효율적인 이유?

: 균형 잡힌 트리 구조 + 트리 깊이의 대수확장성 때문

- 대수확장성: 트리 깊이가 리프 노드의 수에 비해 느리게 성장하는 것.
- 인덱스의 깊이(depth)가 1 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가.

→ 즉, 트리의 깊이가 3이면 최대 인덱스 항목의 수는 64가 된다. (4^3)

## 4.5.3. 인덱스 만드는 방법

---

- 데이터베이스마다 다르다.

### MySQL의 인덱스

1. 클러스터형 인덱스
    - 테이블당 하나 설정 가능.
    - 생성 방법
        1. primary key 옵션으로 기본키 설정
        2. unique not null 옵션 + 기본키X
2. 세컨더리 인덱스
    - 보조 인덱스
    - 여러 개의 필드 값(애트리뷰트)을 기반으로 쿼리를 많이 보낼 때 생성해야 함.
    - 생성 방법 : create index… 명령어 기반.
- 인덱스 하나 생성 시 클러스터형 인덱스를 만드는 것이 성능 측면에서 더 좋다.

### MongoDB

- 도큐먼트 생성 시 자동으로 ObjectID 형성 → ObjectID가 기본키로 설정
- 복합 인덱스 설정 가능 ; 기본키 + 세컨더리키

## 4.5.4. 인덱스 최적화 기법

---

- 데이터베이스마다 다르다. (기본 골조는 같음)

### MongoDB에서의 인덱스 최적화 기법

1. 인덱스 자체가 비용이다.
    - 인덱스는 2번 탐색 : 인덱스 리스트 → 컬렉션
    - 컬렉션 수정 시 인덱스도 수정해야함. → B-트리 조절 비용
    
    → 컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용은 비효율적 
    
2. 항상 테스팅 해야 한다.
    - explain() 함수를 통해 인덱스 생성,쿼리 전송, 테스팅 하는데 걸리는 시간을 최소화해야함.
3. 복합 인덱스 생성 시 순서는 같음, 정렬, 다중 값, 카디널리티 순이다.
    - 복합 인덱스 생성 시 순서에 따라 성능이 달라진다.
        1. ==이나 equal이 포함된 쿼리 → 최우선으로 인덱스로 설정
        2. 정렬에 쓰는 필드
        3. 다중 값을 출력해야 하는 필드 ex. > , < 가 포함도니 쿼리
        4. 카디널리티가 높은 순서. 즉, 특정 칼럼의 값들의 고유도가 높은 것.(중복된 값이 적은 것)
           
# 4.6. 조인의 종류

### 조인(Join)이란?

: 두 개 이상의 테이블을 묶어 하나의 결과물을 만드는 것.

### 조인과 관계형 데이터베이스

- 여러 테이블을 조인하는 작업이 많을 경우 MongoDB보다 관계형 데이터베이스를 쓰는 것이 좋다.
    - MongoDB에는 lookup이라는 조인 연산 쿼리가 있는데 관계형 데이터베이스보다 성능이 떨어지기 때문

## 4.6.1. 내부 조인

---

: 두 테이블 간의 **교집합**

- 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행만 표기

## 4.6.2. 왼쪽 조인

---

: 테이블 A를 기준으로 완전한 레코드 집합을 생성.

- 왼쪽 테이블(A)의 모든 행이 테이블에 표기됨.
    - 테이블 B가 A에 일치하는 부분은 그대로 표기.
    - 테이블 B가 A에 일치하는 항목이 없다면 B 부분은 NULL로 표기.

## 4.6.3. 오른쪽 조인

---

: 테이블 B를 기준으로 완전한 레코드 집합을 생성.

- 오른쪽 테이블(B)의 모든 행이 테이블에 표기됨.
    - 테이블 A가 B에 일치하는 부분은 그대로 표기.
    - 테이블 A가 B에 일치하는 항목이 없다면 A 부분은 NULL로 표기.

 ## 4.6.4. 합집합 조인

---

: 테이블 A와 테이블 B의 완전한 레코드 집합을 생성.

- 테이블 A와 테이블 B의 모든 행이 표기됨.
    - 내부 조인
        - 테이블 A와 B가 일치하는 부분은 그대로 표기.
    - 왼쪽 조인과 오른쪽 조인을 합한 것으로 생각.
        - 테이블 B를 기준으로 테이블 A가 B에 일치하는 항목이 없다면 A 부분은 NULL로 표기.
        - 테이블 A를 기준으로 테이블 B가 A에 일치하는 항목이 없다면 B 부분은 NULL로 표기.
     
# 4.7. 조인의 원리

## 4.7.1. 중첩 루프 조인

---

### 중첩 루프 조인(Nested Loop Join)이란?

: 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법

- EX. 첫 번째 테이블에서 행을 한 번에 하나씩 읽고 두 번째 테이블에서도 행을 하나씩 읽어서 조건에 맞는 레코드를 찾아 결과값을 반환하는 경우
- 대용량 테이블에서 사용X
    
    : 랜덤 접근에 대한 비용이 많이 증가하기 때문.
    

## 4.7.2. 정렬 병합 조인

---

### 정렬 병합 조인이란?

: 각각의 테이블을 조인할 필드(애트리뷰트) 기준으로 정렬하고 조인 작업을 수행하는 조인.

- 언제 사용할까?
    1. 조인 시 사용할 적절한 인덱스가 없는 경우
    2. 대용량의 테이블을 조인 + 조인 조건으로 범위 비교 연산자( < , > )가 있는 경우 사용

## 4.7.3. 해시 조인

---

### 해시 조인이란?

: 해시 테이블을 기반으로 조인하는 방법.

- 동등 조인에서만 사용 가능.
- 두 개의 테이블 조인 시, 하나의 테이블을 메모리에 넣을 수 있다면 중첩 루프 조인보다 효율적.
    
    → 각 테이블은 한 번씩만 읽게 되기 때문에 성능이 더 좋다. 중첩 루프 조인에서는 각 테이블을 중첩해서 읽는다.
    

### MySQL의 해시 조인 단계

1. 빌드 단계
    
    : 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
    
    - 두 개의 테이블을 조인한다면 둘 중 바이트가 더 작은 테이블을 기반으로 함.
    - 조인에 사용되는 필드(애트리뷰트)가 해시 테이블의 키로 사용.
2. 프로브 단계
    - 레코드 읽기 시작
    - 해시 테이블을 기반으로 일치하는 레코드 찾아 결과값으로 반환
